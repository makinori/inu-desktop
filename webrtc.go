package main

import (
	"fmt"
	"io"
	"net/http"
	"strconv"

	"github.com/pion/ice/v4"
	"github.com/pion/webrtc/v4"
)

const WEB_PORT = 4845
const UDP_PORT = 4845

var (
	localPort int

	localWebRTCAPI  *webrtc.API
	publicWebRTCAPI *webrtc.API

	streamVideoTrack *webrtc.TrackLocalStaticRTP
	streamAudioTrack *webrtc.TrackLocalStaticRTP

	peerConfig = webrtc.Configuration{
		// shouldnt need to stun when using nat1to1
		// ICEServers: []webrtc.ICEServer{
		// 	{
		// 		URLs: []string{"stun:stun.l.google.com:19302"},
		// 	},
		// },
	}

	localServeMux  *http.ServeMux
	publicServeMux *http.ServeMux
)

func mustSetupWebRTC() {
	// setup api

	mediaEngine := &webrtc.MediaEngine{}

	err := mediaEngine.RegisterCodec(webrtc.RTPCodecParameters{
		RTPCodecCapability: webrtc.RTPCodecCapability{
			MimeType:     webrtc.MimeTypeH264,
			ClockRate:    90000,
			Channels:     0,
			SDPFmtpLine:  "",
			RTCPFeedback: nil,
		},
		PayloadType: 96,
	}, webrtc.RTPCodecTypeVideo)

	if err != nil {
		panic(err)
	}

	err = mediaEngine.RegisterCodec(webrtc.RTPCodecParameters{
		RTPCodecCapability: webrtc.RTPCodecCapability{
			MimeType:     webrtc.MimeTypeOpus,
			ClockRate:    48000,
			Channels:     2,
			SDPFmtpLine:  "",
			RTCPFeedback: nil,
		},
		PayloadType: 111,
	}, webrtc.RTPCodecTypeAudio)

	if err != nil {
		panic(err)
	}

	// // user configurable RTP/RTCP Pipeline
	// // provides NACKs, RTCP Reports and other features
	// interceptorRegistry := &interceptor.Registry{}

	// // this sends a PLI every 3 seconds
	// // a PLI causes a video keyframe to be generated by the sender
	// // this makes our video seekable and more error resilent,
	// // but at a cost of lower picture quality and higher bitrates
	// intervalPliFactory, err := intervalpli.NewReceiverInterceptor()
	// if err != nil {
	// 	panic(err)
	// }

	// interceptorRegistry.Add(intervalPliFactory)

	// setup public setting engine

	publicUDPMux, err := ice.NewMultiUDPMuxFromPort(UDP_PORT)
	if err != nil {
		panic(err)
	}
	fmt.Printf("public udp listening at %d\n", UDP_PORT)

	publicSettingEngine := webrtc.SettingEngine{}
	publicSettingEngine.SetLite(true)
	publicSettingEngine.SetICEUDPMux(publicUDPMux)
	publicSettingEngine.SetIncludeLoopbackCandidate(false)
	publicSettingEngine.SetInterfaceFilter(func(s string) (keep bool) {
		return false
	})
	publicSettingEngine.SetNetworkTypes([]webrtc.NetworkType{
		webrtc.NetworkTypeUDP4,
	})
	publicSettingEngine.SetNAT1To1IPs(
		[]string{
			"162.233.34.155", // TODO: use dns??
		},
		webrtc.ICECandidateTypeHost,
	)

	// setup local setting engine

	localPort, err = getFreePort()
	if err != nil {
		panic(err)
	}

	localUDPMux, err := ice.NewMultiUDPMuxFromPort(
		localPort, ice.UDPMuxFromPortWithLoopback(),
	)
	if err != nil {
		panic(err)
	}
	fmt.Printf("local udp listening at %d\n", localPort)

	localSettingEngine := webrtc.SettingEngine{}
	localSettingEngine.SetLite(true)
	localSettingEngine.SetICEUDPMux(localUDPMux)
	localSettingEngine.SetIncludeLoopbackCandidate(true)
	localSettingEngine.SetInterfaceFilter(func(s string) (keep bool) {
		return false
	})
	localSettingEngine.SetNetworkTypes([]webrtc.NetworkType{
		webrtc.NetworkTypeUDP4,
	})
	// TODO: gstreamer cant connect to loopback candidate
	// commenting below will let all interfaces cadidate
	localSettingEngine.SetNAT1To1IPs([]string{"127.0.0.1"},
		webrtc.ICECandidateTypeHost,
	)

	// make webrtc apis

	localWebRTCAPI = webrtc.NewAPI(
		webrtc.WithMediaEngine(mediaEngine),
		webrtc.WithSettingEngine(localSettingEngine),
	)

	publicWebRTCAPI = webrtc.NewAPI(
		webrtc.WithMediaEngine(mediaEngine),
		webrtc.WithSettingEngine(publicSettingEngine),
	)

	// setup tracks

	streamVideoTrack, err = webrtc.NewTrackLocalStaticRTP(webrtc.RTPCodecCapability{
		MimeType: webrtc.MimeTypeH264,
	}, "video", "inu")

	if err != nil {
		panic(err)
	}

	streamAudioTrack, err = webrtc.NewTrackLocalStaticRTP(webrtc.RTPCodecCapability{
		MimeType: webrtc.MimeTypeOpus,
	}, "audio", "inu")

	if err != nil {
		panic(err)
	}
}

func writeAnswer(w http.ResponseWriter, peer *webrtc.PeerConnection, offer []byte, path string) {
	peer.OnICEConnectionStateChange(func(state webrtc.ICEConnectionState) {
		fmt.Println(path + " ice: " + state.String())

		if state == webrtc.ICEConnectionStateFailed {
			peer.Close()
		}
	})

	err := peer.SetRemoteDescription(webrtc.SessionDescription{
		Type: webrtc.SDPTypeOffer,
		SDP:  string(offer),
	})

	if err != nil {
		peer.Close()
		panic(err)
	}

	// TODO: should trickle
	gatherComplete := webrtc.GatheringCompletePromise(peer)

	answer, err := peer.CreateAnswer(nil)
	if err != nil {
		peer.Close()
		panic(err)
	}

	err = peer.SetLocalDescription(answer)
	if err != nil {
		peer.Close()
		panic(err)
	}

	<-gatherComplete

	w.Header().Add("Location", path)
	w.WriteHeader(http.StatusCreated)

	// uncomment to see server's sdp
	// fmt.Println(peer.LocalDescription().SDP)

	fmt.Fprint(w, peer.LocalDescription().SDP)
}

func localWhipHandler(w http.ResponseWriter, r *http.Request) {
	offer, err := io.ReadAll(r.Body)
	if err != nil {
		panic(err)
	}

	fmt.Println("got whip")

	// offerStr := string(offer)
	// offerStr = strings.ReplaceAll(offerStr, "192.168.1.36", "127.0.0.1")
	// fmt.Println(offerStr)
	// offer = []byte(offerStr)

	peer, err := localWebRTCAPI.NewPeerConnection(peerConfig)
	if err != nil {
		panic(err)
	}

	_, err = peer.AddTransceiverFromKind(webrtc.RTPCodecTypeVideo)
	if err != nil {
		panic(err)
	}

	_, err = peer.AddTransceiverFromKind(webrtc.RTPCodecTypeAudio)
	if err != nil {
		panic(err)
	}

	peer.OnTrack(func(track *webrtc.TrackRemote, r *webrtc.RTPReceiver) {
		for {

			pkt, _, err := track.ReadRTP()
			if err != nil {
				return
			}

			switch pkt.PayloadType {
			case 96:
				streamVideoTrack.WriteRTP(pkt)
			case 111:
				streamAudioTrack.WriteRTP(pkt)
			}
		}
	})

	writeAnswer(w, peer, offer, "/whip")
}

func publicWhepHandler(w http.ResponseWriter, r *http.Request) {
	offer, err := io.ReadAll(r.Body)
	if err != nil {
		panic(err)
	}

	peer, err := publicWebRTCAPI.NewPeerConnection(peerConfig)
	if err != nil {
		panic(err)
	}

	rtpVideoSender, err := peer.AddTrack(streamVideoTrack)
	if err != nil {
		peer.Close()
		panic(err)
	}

	rtpAudioSender, err := peer.AddTrack(streamAudioTrack)
	if err != nil {
		peer.Close()
		panic(err)
	}

	// read incoming RTCP packets
	// before these packets are returned, they are processed by interceptors.
	// for things like NACK this needs to be called.
	go func() {
		rtcpBuf := make([]byte, 1500)
		for {
			if peer.ConnectionState() == webrtc.PeerConnectionStateClosed {
				break
			}
			rtpVideoSender.Read(rtcpBuf)
			rtpAudioSender.Read(rtcpBuf)
		}
	}()

	writeAnswer(w, peer, offer, "/whep")
}

func initWebRTC() chan bool {
	keepAlive := make(chan bool)

	mustSetupWebRTC()

	publicServeMux := http.NewServeMux()
	publicServeMux.HandleFunc("POST /whep", publicWhepHandler)
	publicServeMux.Handle("/", http.FileServer(http.Dir(".")))

	fmt.Println("public http listening at http://127.0.0.1:" + strconv.Itoa(WEB_PORT))
	go func() {
		err := http.ListenAndServe(":"+strconv.Itoa(WEB_PORT), publicServeMux)
		if err != nil {
			panic(err)
		}
	}()

	localServeMux = http.NewServeMux()
	localServeMux.HandleFunc("POST /whip", localWhipHandler)

	fmt.Println("local http listening at http://127.0.0.1:" + strconv.Itoa(localPort))
	go func() {
		err := http.ListenAndServe(":"+strconv.Itoa(localPort), localServeMux)
		if err != nil {
			panic(err)
		}
	}()

	// go func() {
	// 	l, err := net.ListenUDP("udp", &net.UDPAddr{
	// 		IP: net.ParseIP("127.0.0.1"), Port: 5004,
	// 	})
	// 	if err != nil {
	// 		panic(err)
	// 	}

	// 	bufferSize := 300000 // 300KB
	// 	err = l.SetReadBuffer(bufferSize)
	// 	if err != nil {
	// 		panic(err)
	// 	}

	// 	defer func() {
	// 		err = l.Close()
	// 		if err != nil {
	// 			panic(err)
	// 		}
	// 	}()

	// 	inboundRTPPacket := make([]byte, 1600)
	// 	for {
	// 		n, _, err := l.ReadFrom(inboundRTPPacket)
	// 		if err != nil {
	// 			panic(fmt.Sprintf("error during read: %s", err))
	// 		}

	// 		// fmt.Println(n)

	// 		_, err = streamVideoTrack.Write(inboundRTPPacket[:n])
	// 		if err != nil {
	// 			fmt.Println(err)
	// 			if errors.Is(err, io.ErrClosedPipe) {
	// 				// The peerConnection has been closed.
	// 				return
	// 			}

	// 			panic(err)
	// 		}
	// 	}
	// }()

	return keepAlive
}
