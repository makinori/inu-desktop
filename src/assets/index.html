<html>
	<head>
		<title>Inu Desktop</title>
		<style>
			@font-face {
				font-family: "SN Pro";
				font-style: normal;
				font-display: swap;
				src: url(./fonts/SNPro-VariableRegular.woff2) format("woff2");
			}

			@font-face {
				font-family: "SN Pro";
				font-style: italic;
				font-display: swap;
				src: url(./fonts/SNPro-VariableItalic.woff2) format("woff2");
			}

			* {
				margin: 0;
				user-select: none;
			}

			:root {
				--controls-height: 48px;
			}

			body {
				background: #000;
				color: #fff;
				font-family: "SN Pro", sans-serif;
			}

			#video {
				position: fixed;
				margin: auto;
				top: 0;
				left: 0;
				right: 0;
				bottom: var(--controls-height);
				width: 100vw;
				height: calc(100vh - var(--controls-height));
			}

			.controls-background {
				position: fixed;
				margin: auto;
				left: 0;
				right: 0;
				bottom: 0;
				height: var(--controls-height);
				background-color: #111;
			}

			.controls {
				position: fixed;
				margin: auto;
				left: 0;
				right: 0;
				bottom: 0;
				height: var(--controls-height);
				padding: 0 24px;
				opacity: 0.5;
			}

			.hstack {
				display: flex;
				align-items: center;
				justify-content: center;
				gap: 8px;
			}

			.controls-seperator {
				margin: 0 12px;
			}

			#init {
				position: fixed;
				margin: auto;
				left: 0;
				right: 0;
				bottom: 0;
				top: 0;
				display: flex;
				align-items: center;
				justify-content: center;
				background-color: rgba(17, 17, 17, 0.85);
				z-index: 9999;
				text-align: center;
				cursor: pointer;
			}

			#volume-slider {
				width: 150px;
				filter: grayscale(1);
			}

			.icon-button {
				cursor: pointer;
			}

			.controls > p {
				font-weight: 600;
			}
		</style>
	</head>
	<body>
		<div id="init">
			<img src="./icons/volume.svg" height="128" />
		</div>
		<video id="video" autoplay></video>
		<div class="controls-background"></div>
		<div class="controls hstack">
			<img
				id="volume-mute"
				class="icon-button"
				src="./icons/volume.svg"
				x-icon-false="./icons/volume.svg"
				x-icon-true="./icons/volume-slash.svg"
				height="24"
			/>
			<input
				type="range"
				min="0"
				max="1"
				value="0"
				step="0.01"
				id="volume-slider"
			/>
			<div class="controls-seperator"></div>
			<div class="hstack" style="gap: 4px">
				<img
					src="./icons/clipboard-list.svg"
					height="28"
					style="opacity: 0.5"
				/>
				<img
					title="Upload Clipboard"
					id="clipboard-upload"
					class="icon-button"
					src="./icons/arrow-up-to-line.svg"
					height="26"
				/>
				<img
					title="Download Clipboard"
					id="clipboard-download"
					class="icon-button"
					src="./icons/arrow-down-to-line.svg"
					height="26"
				/>
			</div>
			<div class="controls-seperator"></div>
			<img
				title="Toggle Controls"
				id="controls-toggle"
				class="icon-button"
				src="./icons/arrow-pointer.svg"
				x-icon-true="./icons/arrow-pointer.svg"
				x-icon-false="./icons/arrow-pointer-slash.svg"
				height="26"
			/>
			<div class="controls-seperator"></div>
			<img
				title="Reload"
				id="reload"
				class="icon-button"
				src="./icons/rotate-right.svg"
				height="24"
			/>
			<div class="controls-seperator"></div>
			<p id="viewers-text"></p>
		</div>
	</body>
	<script src="./js/guacamole-keyboard.js"></script>
	<script>
		function iconBoolBinding(el, defaultValue = false) {
			let checked = defaultValue;
			const updateIcon = () => {
				if (checked) {
					el.src = el.getAttribute("x-icon-true");
				} else {
					el.src = el.getAttribute("x-icon-false");
				}
			};
			updateIcon();
			return {
				el,
				set checked(value) {
					checked = value;
					updateIcon();
				},
				get checked() {
					return checked;
				},
			};
		}

		const initEl = document.getElementById("init");
		const video = document.getElementById("video");

		const volumeSlider = document.getElementById("volume-slider");
		const volumeMute = iconBoolBinding(
			document.getElementById("volume-mute"),
		);

		const controls = iconBoolBinding(
			document.getElementById("controls-toggle"),
			true,
		);

		const clipboardUpload = document.getElementById("clipboard-upload");
		const clipboardDownload = document.getElementById("clipboard-download");

		const reloadButton = document.getElementById("reload");

		const viewersText = document.getElementById("viewers-text");

		const url = new URL(document.URL);
		const https = url.protocol.includes("https");
		const ws = new WebSocket(
			(https ? "wss://" : "ws://") + url.host + "/api/ws",
		);

		volumeSlider.addEventListener("input", e => {
			video.volume = Number(e.target.value);
		});

		volumeMute.el.addEventListener("click", () => {
			video.muted = !volumeMute.checked;
		});

		var lastVolume;
		var lastMuted;
		function updateVolumeControls() {
			if (lastVolume == video.volume && lastMuted == video.muted) {
				return;
			}
			lastVolume = video.volume;
			lastMuted = video.muted;
			if (video.volume == 0 || video.muted) {
				volumeMute.checked = true;
				volumeSlider.value = 0;
			} else {
				volumeMute.checked = false;
				volumeSlider.value = video.volume;
			}
		}

		video.addEventListener("volumechange", () => {
			localStorage.setItem(
				"volume",
				JSON.stringify({
					volume: video.volume,
					muted: video.muted,
				}),
			);
			updateVolumeControls();
		});

		video.volume = 0.8;
		video.muted = false;

		const savedVolume = localStorage.getItem("volume");
		if (savedVolume) {
			try {
				const { volume, muted } = JSON.parse(savedVolume);
				video.volume = volume;
				video.muted = muted;
			} catch (error) {}
		}

		updateVolumeControls();

		controls.el.addEventListener("click", () => {
			controls.checked = !controls.checked;
		});

		let initElDismissed = false;
		function canControl() {
			return initElDismissed && controls.checked;
		}

		function convertTypedArray(src, type) {
			const buffer = new ArrayBuffer(src.byteLength);
			const baseView = new src.constructor(buffer).set(src);
			return new type(buffer);
		}

		function getNormalizedCoords(offsetX, offsetY) {
			if (video.videoWidth == 0 || video.videoHeight == 0) {
				return null;
			}

			const rect = video.getBoundingClientRect();
			let x = offsetX / rect.width;
			let y = offsetY / rect.height;

			const streamRatio = video.videoWidth / video.videoHeight;
			const elRatio = rect.width / rect.height;

			if (streamRatio > elRatio) {
				// scale vertically
				y -= (1 - elRatio / streamRatio) * 0.5;
				y *= streamRatio / elRatio;
			} else {
				// scale horizontally
				x -= (1 - streamRatio / elRatio) * 0.5;
				x *= elRatio / streamRatio;
			}

			if (x < 0 || y < 0 || x > 1 || y > 1) {
				return null;
			}

			return [x, y];
		}

		const WSEventMouseMove = 0;
		const WSEventMouseClick = 1;
		const WSEventKeyPress = 2;
		const WSEventScroll = 3;
		const WSEventClipboardUpload = 4;
		const WSEventClipboardDownload = 5;
		const WSEventViewerCount = 6;

		video.addEventListener("mousemove", e => {
			if (!canControl()) {
				return;
			}

			e.preventDefault();

			const coords = getNormalizedCoords(e.offsetX, e.offsetY);
			if (coords == null) {
				return;
			}

			const data = new Uint8Array([
				WSEventMouseMove,
				...convertTypedArray(new Float32Array(coords), Uint8Array),
			]);

			ws.send(data);
		});

		video.addEventListener("contextmenu", e => {
			e.preventDefault();
		});

		function sendMouseDownUp(e, down) {
			if (!canControl()) {
				return;
			}

			e.preventDefault();

			const coords = getNormalizedCoords(e.offsetX, e.offsetY);
			if (coords == null) {
				return;
			}

			const data = new Uint8Array([
				WSEventMouseClick,
				e.button,
				down ? 1 : 0,
			]);

			ws.send(data);
		}

		video.addEventListener("mousedown", e => {
			sendMouseDownUp(e, true);
		});

		video.addEventListener("mouseup", e => {
			sendMouseDownUp(e, false);
		});

		const keyboard = new Guacamole.Keyboard(document);

		async function sendKeyPress(keysym, down) {
			if (!canControl()) {
				return;
			}

			const data = new Uint8Array([
				WSEventKeyPress,
				...convertTypedArray(new Uint32Array([keysym]), Uint8Array),
				down ? 1 : 0,
			]);

			ws.send(data);
		}

		keyboard.onkeydown = keysym => {
			sendKeyPress(keysym, true);
		};

		keyboard.onkeyup = keysym => {
			sendKeyPress(keysym, false);
		};

		video.addEventListener("wheel", e => {
			if (!canControl()) {
				return;
			}

			if (e.deltaY == 0) {
				return;
			}

			const data = new Uint8Array([WSEventScroll, e.deltaY > 0 ? 1 : 0]);

			ws.send(data);
		});

		// let peer = new RTCPeerConnection();
		// peer = null;
		let peer;

		const onIceChange = () => {
			console.log(peer.iceConnectionState);
			if (
				peer.iceConnectionState == "disconnected" ||
				peer.iceConnectionState == "failed" ||
				peer.iceConnectionState == "closed"
			) {
				init();
			}
		};

		const onTrack = event => {
			video.srcObject = event.streams[0];
			video.play(); // will fail if user hasnt clicked yet
		};

		async function init() {
			console.log("initializing...");

			if (peer != null) {
				console.log("closing...");
				peer.removeEventListener(
					"iceconnectionstatechange",
					onIceChange,
				);
				peer.removeEventListener("track", onTrack);
				peer.close();
			}

			peer = new RTCPeerConnection();

			peer.addEventListener("iceconnectionstatechange", onIceChange);
			peer.addEventListener("track", onTrack);

			peer.addTransceiver("video", { direction: "recvonly" });
			peer.addTransceiver("audio", { direction: "recvonly" });

			const offer = await peer.createOffer();

			peer.setLocalDescription(offer);

			// console.log(offer.sdp);

			const res = await fetch(`/whep`, {
				method: "POST",
				body: offer.sdp,
				headers: {
					"Content-Type": "application/sdp",
				},
			});

			const answer = await res.text();

			peer.setRemoteDescription({
				sdp: answer,
				type: "answer",
			});
		}

		reloadButton.addEventListener("click", () => {
			document.location = document.location;
		});

		clipboardUpload.addEventListener("click", async () => {
			try {
				const text = https
					? await navigator.clipboard.readText()
					: "need https to get clipboard";
			} catch (error) {
				alert("failed to get system clipboard:\n" + error);
			}

			const data = new Uint8Array([
				WSEventClipboardUpload,
				...new TextEncoder().encode(text),
			]);

			ws.send(data);
		});

		clipboardDownload.addEventListener("click", () => {
			ws.send(new Uint8Array([WSEventClipboardDownload]));
		});

		function plural(n, single, plural = null) {
			if (plural == null) plural = single + "s";
			if (n == 1 || n == -1) return n + " " + single;
			else return n + " " + plural;
		}

		ws.addEventListener("message", async e => {
			if (e.data.size == 0) {
				return;
			}

			const data = await e.data.bytes();

			switch (data[0]) {
				case WSEventClipboardDownload:
					const clipboard = new TextDecoder().decode(data.slice(1));
					try {
						await navigator.clipboard.writeText(value);
					} catch (error) {
						alert("failed to set system clipboard:\n" + error);
					}
					break;

				case WSEventViewerCount:
					const viewers = convertTypedArray(
						data.slice(1),
						Uint32Array,
					)[0];
					viewersText.textContent = plural(viewers, "viewer");
					break;
			}
		});

		init();

		initEl.addEventListener("click", () => {
			initEl.remove();
			video.play();
			initElDismissed = true;
		});
	</script>
</html>
