package inuwebrtc

import (
	"context"
	"fmt"
	"io"
	"log/slog"
	"net"
	"net/http"
	"slices"
	"strconv"
	"sync"
	"sync/atomic"

	"github.com/makinori/inu-desktop/src/config"
	"github.com/maniartech/signals"
	"github.com/pion/ice/v4"
	"github.com/pion/webrtc/v4"
)

var (
	LocalRtpVideoPort int
	LocalRtpAudioPort int

	api *webrtc.API

	videoTrack *webrtc.TrackLocalStaticRTP
	audioTrack *webrtc.TrackLocalStaticRTP

	peerConfig = webrtc.Configuration{
		// shouldnt need to stun when using nat1to1
		// ICEServers: []webrtc.ICEServer{
		// 	{
		// 		URLs: []string{"stun:stun.l.google.com:19302"},
		// 	},
		// },
	}

	connectedPeers      []*webrtc.PeerConnection
	connectedPeersMutex sync.RWMutex

	ViewerCount       atomic.Uint32
	ViewerCountSignal = signals.New[uint32]()
)

func initWebRTC() {
	// setup api

	mediaEngine := &webrtc.MediaEngine{}

	err := mediaEngine.RegisterCodec(webrtc.RTPCodecParameters{
		RTPCodecCapability: webrtc.RTPCodecCapability{
			MimeType:     webrtc.MimeTypeH264,
			ClockRate:    90000,
			Channels:     0,
			SDPFmtpLine:  "",
			RTCPFeedback: nil,
		},
		PayloadType: 96,
	}, webrtc.RTPCodecTypeVideo)

	if err != nil {
		panic(err)
	}

	err = mediaEngine.RegisterCodec(webrtc.RTPCodecParameters{
		RTPCodecCapability: webrtc.RTPCodecCapability{
			MimeType:     webrtc.MimeTypeOpus,
			ClockRate:    48000,
			Channels:     2,
			SDPFmtpLine:  "",
			RTCPFeedback: nil,
		},
		PayloadType: 111,
	}, webrtc.RTPCodecTypeAudio)

	if err != nil {
		panic(err)
	}

	// // user configurable RTP/RTCP Pipeline
	// // provides NACKs, RTCP Reports and other features
	// interceptorRegistry := &interceptor.Registry{}

	// // this sends a PLI every 3 seconds
	// // a PLI causes a video keyframe to be generated by the sender
	// // this makes our video seekable and more error resilent,
	// // but at a cost of lower picture quality and higher bitrates
	// intervalPliFactory, err := intervalpli.NewReceiverInterceptor()
	// if err != nil {
	// 	panic(err)
	// }

	// interceptorRegistry.Add(intervalPliFactory)

	// setup api

	udpMux, err := ice.NewMultiUDPMuxFromPort(config.UDP_PORT)
	if err != nil {
		panic(err)
	}
	slog.Info("public udp listening at " + strconv.Itoa(config.UDP_PORT))

	settingEngine := webrtc.SettingEngine{}
	settingEngine.SetLite(true)
	settingEngine.SetICEUDPMux(udpMux)
	settingEngine.SetIncludeLoopbackCandidate(false)
	settingEngine.SetInterfaceFilter(func(s string) (keep bool) {
		return false
	})
	settingEngine.SetNetworkTypes([]webrtc.NetworkType{
		webrtc.NetworkTypeUDP4,
	})
	settingEngine.SetNAT1To1IPs(
		[]string{
			config.PUBLIC_IP, // TODO: use dns??
		},
		webrtc.ICECandidateTypeHost,
	)

	slog.Info("nat 1 to 1 set to " + config.PUBLIC_IP)

	api = webrtc.NewAPI(
		webrtc.WithMediaEngine(mediaEngine),
		webrtc.WithSettingEngine(settingEngine),
		// webrtc.WithInterceptorRegistry(interceptorRegistry),
	)

	// setup tracks

	videoTrack, err = webrtc.NewTrackLocalStaticRTP(webrtc.RTPCodecCapability{
		MimeType: webrtc.MimeTypeH264,
	}, "video", "inu")

	if err != nil {
		panic(err)
	}

	audioTrack, err = webrtc.NewTrackLocalStaticRTP(webrtc.RTPCodecCapability{
		MimeType: webrtc.MimeTypeOpus,
	}, "audio", "inu")

	if err != nil {
		panic(err)
	}
}

func writeAnswer(
	w http.ResponseWriter, r *http.Request, peer *webrtc.PeerConnection,
	offer []byte, path string,
) {
	peer.OnICEConnectionStateChange(func(state webrtc.ICEConnectionState) {
		slog.Info(getRequestIP(r) + " ice " + state.String())

		if state == webrtc.ICEConnectionStateFailed {
			peer.Close()
		}
	})

	// fmt.Println(string(offer))

	err := peer.SetRemoteDescription(webrtc.SessionDescription{
		Type: webrtc.SDPTypeOffer,
		SDP:  string(offer),
	})

	if err != nil {
		peer.Close()
		panic(err)
	}

	// can trickle ice packets with a PATCH request
	// however i dont think it makes any sense when using nat1to1

	gatherComplete := webrtc.GatheringCompletePromise(peer)

	answer, err := peer.CreateAnswer(nil)
	if err != nil {
		peer.Close()
		panic(err)
	}

	err = peer.SetLocalDescription(answer)
	if err != nil {
		peer.Close()
		panic(err)
	}

	<-gatherComplete

	w.Header().Add("Location", path)
	w.WriteHeader(http.StatusCreated)

	// fmt.Println(peer.LocalDescription().SDP)

	fmt.Fprint(w, peer.LocalDescription().SDP)
}

func updateViewerCount() {
	connectedPeersMutex.RLock()
	value := uint32(len(connectedPeers))
	connectedPeersMutex.RUnlock()

	if ViewerCount.Load() == value {
		return
	}

	ViewerCount.Store(value)
	ViewerCountSignal.Emit(context.Background(), value)
}

func whepHandler(w http.ResponseWriter, r *http.Request) {
	offer, err := io.ReadAll(r.Body)
	if err != nil {
		panic(err)
	}

	peer, err := api.NewPeerConnection(peerConfig)
	if err != nil {
		panic(err)
	}

	peer.OnConnectionStateChange(func(connState webrtc.PeerConnectionState) {
		switch connState {
		case webrtc.PeerConnectionStateConnected:
			connectedPeersMutex.Lock()
			if slices.Contains(connectedPeers, peer) {
				return
			}
			connectedPeers = append(connectedPeers, peer)
			connectedPeersMutex.Unlock()

			updateViewerCount()

		case webrtc.PeerConnectionStateDisconnected,
			webrtc.PeerConnectionStateFailed,
			webrtc.PeerConnectionStateClosed:

			connectedPeersMutex.Lock()
			i := slices.Index(connectedPeers, peer)
			if i < 0 {
				break
			}
			connectedPeers = slices.Delete(connectedPeers, i, i+1)
			connectedPeersMutex.Unlock()

			updateViewerCount()
		}
	})

	rtpVideoSender, err := peer.AddTrack(videoTrack)
	if err != nil {
		peer.Close()
		panic(err)
	}

	rtpAudioSender, err := peer.AddTrack(audioTrack)
	if err != nil {
		peer.Close()
		panic(err)
	}

	// read incoming RTCP packets
	// before these packets are returned, they are processed by interceptors.
	// for things like NACK this needs to be called.
	go func() {
		rtcpBuf := make([]byte, 1500)
		for {
			if peer.ConnectionState() == webrtc.PeerConnectionStateClosed {
				break
			}
			rtpVideoSender.Read(rtcpBuf)
			rtpAudioSender.Read(rtcpBuf)
		}
	}()

	writeAnswer(w, r, peer, offer, "/whep")
}

func udpServerForRTPToTrack(
	port int, track *webrtc.TrackLocalStaticRTP,
) {
	l, err := net.ListenUDP("udp", &net.UDPAddr{
		IP: net.ParseIP("127.0.0.1"), Port: port,
	})
	if err != nil {
		panic(err)
	}

	bufferSize := 300000 // 300KB
	err = l.SetReadBuffer(bufferSize)
	if err != nil {
		panic(err)
	}

	defer func() {
		err = l.Close()
		if err != nil {
			panic(err)
		}
	}()

	packet := make([]byte, 1600)
	for {
		n, _, err := l.ReadFrom(packet)
		if err != nil {
			slog.Error("rtp track read error", "err", err)
			continue
		}

		track.Write(packet[:n])
	}
}

func Init(httpMux *http.ServeMux) {
	initWebRTC()

	httpMux.HandleFunc("POST /whep", whepHandler)

	var err error

	LocalRtpVideoPort, err = getFreeUDPPort()
	if err != nil {
		panic(err)
	}

	LocalRtpAudioPort, err = getFreeUDPPort()
	if err != nil {
		panic(err)
	}

	slog.Info(
		"local rtp listening", "video", LocalRtpVideoPort,
		"audio", strconv.Itoa(LocalRtpAudioPort),
	)

	go udpServerForRTPToTrack(LocalRtpVideoPort, videoTrack)
	go udpServerForRTPToTrack(LocalRtpAudioPort, audioTrack)
}
